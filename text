const mysql = require("mysql")
const mysql_sync = require("sync-mysql")
require("dotenv").config()
const { conf } = require("../config/app_config")

const _val = (value) => {
  return value === null
    ? "NULL"
    : typeof value === "boolean"
    ? value
      ? 1
      : 0
    : value === undefined
    ? ""
    : "'" + value + "'"
}

const _col = (column) => {
  return "`" + column + "`"
}

const executeQuery = (query) => {
  const mode = process.env.NODE_ENV ?? "production"
  const config = conf.database[mode]

  return new Promise((resolve, reject) => {
    let connection = mysql.createConnection(config)
    connection.connect((error) => {
      if (error) {
        reject(error)
      }
      connection.query(query, (error, result) => {
        error ? reject(error) : resolve(result)
      })
    })
  })
}

/* 
* const DB = (query) => {
  try {
    const connection = new mysql_sync({
      host: "localhost",
      user: "root",
      port: 3306,
      password: "",
      database: "webtop_db",
    })
    return connection.query(query)
  } catch (error) {
    return { error }
  }
}

const products = DB("SELECT * FROM products LIMIT 3")
console.log("products", products)

*/

const createQueryBuilder = (table) => {
  return {
    _tableName: table,
    _table: _col(table),
    _r_table: null,
    _table_r: null,
    _conditions: [],
    _orders: [],
    _limit: null,
    _paginate: null,
    _add_to_end: null,
  }
}

const DB = (table) => {
  //"SELECT * FROM products WHERE disable = 0 LIMIT 10"
  let {
    _table,
    _r_table,
    _table_r,
    _conditions,
    _orders,
    _limit,
    _paginate,
    _add_to_end,
  } = createQueryBuilder(table)

  const where = (column, conditionOrValue, value) => {
    if (arguments.length < 2) {
      return
    }
    if (arguments.length < 3) {
      _conditions.push("AND", _col(column), "=", _val(conditionOrValue))
    } else {
      _conditions.push("AND", _col(column), conditionOrValue, _val(value))
    }
  }

  const whereNotNull = (column) => {}

  const orWhere = (column, conditionOrValue, value) => {
    if (arguments.length < 2) {
      return
    }
    if (arguments.length < 3) {
      _conditions.push("OR", _col(column), "=", _val(conditionOrValue))
    } else {
      _conditions.push("OR", _col(column), conditionOrValue, _val(value))
    }
  }

  const whereIn = (column, arr) => {
    if (arguments.length < 2 || !Array.isArray(arr)) {
      return
    }
    arr = arr.map((ar) => _val(ar))
    _conditions.push("AND", _col(column), "IN(", arr.join(", ") + ")")
  }

  const orWhereIn = (column, arr) => {
    if (arguments.length < 2 || !Array.isArray(arr)) {
      return
    }
    arr = arr.map((ar) => _val(ar))
    _conditions.push("OR", _col(column), "IN(", arr.join(", ") + ")")
  }

  const orderBy = (column, ascOrDesc = "ASC") => {
    if (
      arguments.length < 2 ||
      (ascOrDesc.toUpperCase() !== "ASC" && ascOrDesc.toUpperCase() !== "DESC")
    ) {
      return
    }
    _orders.push(_col(column) + " " + ascOrDesc.toUpperCase())
  }

  const limit = (limitValue) => {
    if (limitValue !== undefined) {
      _limit = limitValue
    }
  }

  const paginate = (page, perPage) => {
    if (page && perPage) {
      _paginate = { page, perPage }
    }
  }

  const whereHas = (relation, fn) => {
    // let query = this
    // fn(query)
  }

  const orWhereHas = () => {}

  const get = (columns = "*") => {
    if (Array.isArray(columns)) {
      columns = columns.map((col) => _col(col)).join(", ")
    }
    _r_table = "SELECT " + columns + " FROM"
    return _queryBuilder()
  }

  const deleteRecord = () => {
    _r_table = "DELETE FROM"
    return _queryBuilder()
  }

  const update = (obj = {}) => {
    _r_table = "UPDATE"
    _table_r = "SET"
    let set = []
    if (
      typeof obj === "object" &&
      obj !== null &&
      Object.keys(obj).length > 0
    ) {
      for (let column in obj) {
        set.push(_col(column) + " = " + _val(obj[column]))
      }
      _table_r = "SET " + set.join(", ")
    }
    return _queryBuilder()
  }

  const create = (obj = {}) => {
    _r_table = "INSERT INTO"
    if (Array.isArray(obj) && obj.length > 0) {
      let columns = []
      let all_values = []
      for (let column in obj[0]) {
        columns.push(column)
      }
      obj.forEach((objItem) => {
        let values = []
        columns.forEach((column) => {
          values.push(_val(objItem[column]))
        })
        all_values.push("(" + values.join(", ") + ")")
      })
      _table_r = "(" + columns.join(", ") + ") VALUES " + all_values.join(", ")
    } else if (
      typeof obj === "object" &&
      obj !== null &&
      Object.keys(obj).length > 0
    ) {
      let columns = []
      let values = []
      for (let column in obj) {
        columns.push(_col(column))
        values.push(_val(obj[column]))
      }
      _table_r =
        "(" +
        columns.map((column) => _col(column)).join(", ") +
        ") VALUES (" +
        values.join(", ") +
        ")"
    }
    return _queryBuilder()
  }

  const find = async (id, columns = "*") => {
    if (Array.isArray(columns)) {
      columns = columns.map((col) => _col(col)).join(", ")
    }
    _r_table = "SELECT " + columns + " FROM"
    _limit = 1
    if (arguments.length > 0 && id !== undefined && isFinite(id)) {
      _conditions.push("AND", _col("id"), "=", _val(id))
    }
    let answer = await _queryBuilder()
    return answer.length > 0 ? answer[0] : null
  }

  const first = async (columns = "*") => {
    if (Array.isArray(columns)) {
      columns = columns.map((col) => _col(col)).join(", ")
    }
    _r_table = "SELECT " + columns + " FROM"
    _limit = 1
    let answer = await _queryBuilder()
    return answer.length > 0 ? answer[0] : null
  }

  const count = async () => {
    _r_table = "SELECT COUNT(*) FROM"
    let answer = await _queryBuilder()
    return answer[0][Object.keys(answer[0])[0]]
  }

  const exists = async () => {
    _r_table = "SELECT EXISTS (SELECT * FROM"
    _add_to_end = ")"
    let answer = await _queryBuilder()
    return answer[0][Object.keys(answer[0])[0]] !== 0
  }

  const sum = async (column) => {
    _r_table = "SELECT SUM(" + _col(column) + ") FROM"
    let answer = await _queryBuilder()
    return answer[0][Object.keys(answer[0])[0]]
  }

  const truncate = () => {
    _r_table = "TRUNCATE TABLE"
    return _queryBuilder()
  }

  const _queryBuilder = () => {
    let queryComponents = [_r_table, _table]
    _table_r !== null ? queryComponents.push(_table_r) : null
    if (_conditions.length > 0) {
      _conditions[0] = "WHERE"
      queryComponents.push(..._conditions)
    }
    if (_orders.length > 0) {
      queryComponents.push("ORDER BY")
      queryComponents.push(_orders.join(", "))
    }
    if (_limit !== null) {
      queryComponents.push("LIMIT " + _limit)
    } else if (_paginate !== null) {
      queryComponents.push("LIMIT " + _paginate.perPage)
    }
    if (_paginate !== null) {
      queryComponents.push("OFFSET " + _paginate.perPage * (_paginate.page - 1))
    }
    _add_to_end !== null ? queryComponents.push(_add_to_end) : null
    let query = queryComponents.join(" ")
    console.log("query =", query)
    return executeQuery(query)
  }

  return {
    where,
    whereNotNull,
    orWhere,
    whereIn,
    orWhereIn,
    orderBy,
    limit,
    paginate,
    whereHas,
    orWhereHas,
    get,
    delete: deleteRecord,
    update,
    create,
    find,
    first,
    count,
    exists,
    sum,
    truncate,
  }
}

module.exports = { executeQuery, DB }

/**
 {
 "firstName": "web",
 "lastName": "top",
 "email": "web@top.com",
 "password": "123456"
}
 */
// +++++++++++++++ app.js ++++++++++++++++++++++++
const express = require("express")
const app = express()
const path = require("path")
const cookieParser = require("cookie-parser")
// const log = require("./components/logger")
const session = require("express-session")
const bodyParser = require("body-parser") //To access the parameters passed with API request
const cors = require("cors") //To handle the cross origin resource sharing
// configure our .env file
require("dotenv").config() //is used to load the .env file, so that using process.env.{KEY} we can access the environment variables defined in the .env file. */
const mediaController = require("./http/controllers/mediaController/mediaController")

global.__basedir = __dirname
// Express body parser
// app.use(cors())
app.use(bodyParser.json())
app.use(
  bodyParser.urlencoded({
    limit: "50mb",
    extended: true,
    parameterLimit: 50000,
  })
)

const webRouter = require("./routes/web")
const apiRouter = require("./routes/api_v1")
const mediaRouter = require("./routes/api_v1_media")

// For postman form-data
// const formData = require("express-form-data")
// const os = require("node:os")
// app.use(formData.parse({ uploadDir: os.tmpdir(), autoClean: true }))
// app.use(formData.union())

const authMiddleware = require("./middlewares/authMiddleware")
const api_auth = require("./middlewares/api_auth")
const {
  notFoundHandler,
  errorHandler,
} = require("./middlewares/errorMiddleware")
// log.info("This is an information message.")

//---------------------cron jobs-begin---------------------------------------------
require("./jobs/sessionCleaner")
require("./jobs/logFileCleaner")
//---------------------cron jobs-end-----------------------------------------------

// Install ejs
app.use(require("express-ejs-layouts"))
app.set("layout", "layouts/includes/contentTemplate")
app.set("views", path.join(__dirname, "views"))
app.set("view engine", "ejs")

// app.use(express.json())
// app.use(express.urlencoded({ extended: false }))

app.use(cookieParser())
app.use(express.static(path.join(__dirname, "public")))

// File upload configs

// const fileUpload = require("express-fileupload")
// app.use(
//   fileUpload({
//     limits: { fileSize: 50 * 1024 * 1024 },
// useTempFiles: true,
// tempFileDir: __dirname + "/tmp",
// safeFileNames: true,
// preserveExtension: true,
//   })
// )

app.use(
  session({
    name: "ses",
    secret: "Fb25ekS7Im", // Use a strong secret in production
    resave: true,
    saveUninitialized: true,
    cookie: { maxAge: 10 * 60 * 1000 }, // Set the cookie expiration time
  })
)

app.use(authMiddleware)
app.use(api_auth)

app.use(mediaController.uploadFile)

app.use("/", webRouter)
app.use("/api/v1", apiRouter)
app.use("/api/v1/media", mediaRouter)

// Use the error handling middleware
app.use(notFoundHandler)
app.use(errorHandler)

module.exports = app

// +++++++++++++++++++++++++++++++++++


  // Handle employee avatar upload
  let userAvatar = req.files ? req.files.image : null
  let avatar = null
  if (userAvatar) {
    try {
      const userAvatarPath = "storage/uploads/userAvatar/"
      avatar = await handleFileUpload(userAvatar, 0, userAvatarPath)
    } catch (error) {
      res.status(422)
      return res.send({ errors: error.message })
    }
  }

  // Handle user images upload

  let imagesJson = null
  let userImages = {}
  if (images) {
    try {
      const userPhotoPath = "storage/uploads/usersImages/"
      await Promise.all(
        images.map(async (image, index) => {
          const imageName = await handleFileUpload(image, index, userPhotoPath)
          const key = "Image_" + index
          userImages[key] = imageName
        })
      )
      imagesJson = JSON.stringify(userImages)
    } catch (error) {
      res.status(422)
      return res.send({ errors: error.message })
    }
  }

  let newEmployeeData = {
    firstName,
    lastName,
    image: avatar,
    images: imagesJson,
    rank: rank,
    title,
    description,
    email,
    password: bcrypt.hashSync(password, 8),
    emailVerifyedAt: moment().format("yyyy-MM-DD HH:mm:ss"),
    createdAt: moment().format("yyyy-MM-DD HH:mm:ss"),
    updatedAt: moment().format("yyyy-MM-DD HH:mm:ss"),
  }

  try {
    await DB("users").create(newEmployeeData)
  } catch (e) {
    console.error(e)
    res.status(422)
    return res.send({ errors: "User not created." })
  }
  // await userNotification(
  //   email,
  //   "Employee created",
  //   '<div style="font-size: 35px;color: #077">Hello, You are registered in WebTop, your password: ' +
  //     password +
  //     "</div>",
  //   "html"
  // )
